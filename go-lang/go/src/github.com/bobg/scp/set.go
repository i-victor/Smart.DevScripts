// This file generated by genset.go
package scp

import "sort"

// ValueSet is a set of Value, implemented as a sorted slice.
type ValueSet []Value

func (vs ValueSet) find(v Value) int {
	return sort.Search(len(vs), func(index int) bool {
		return !vs[index].Less(v)
	})
}

func ValueEqual(a, b Value) bool {
	return !a.Less(b) && !b.Less(a)
}

// Add produces a ValueSet containing the members of vs plus the
// element v.
func (vs ValueSet) Add(v Value) ValueSet {
	index := vs.find(v)
	if index < len(vs) && ValueEqual(v, vs[index]) {
		return vs
	}
	var result ValueSet
	result = append(result, vs[:index]...)
	result = append(result, v)
	result = append(result, vs[index:]...)
	return result
}

// Union produces a ValueSet containing all the members of both sets.
func (vs ValueSet) Union(other ValueSet) ValueSet {
	if len(vs) == 0 {
		return other
	}
	if len(other) == 0 {
		return vs
	}
	var (
		i, j   int
		result ValueSet
	)
	for i < len(vs) && j < len(other) {
		switch {
		case vs[i].Less(other[j]):
			result = append(result, vs[i])
			i++
		case other[j].Less(vs[i]):
			result = append(result, other[j])
			j++
		default:
			result = append(result, vs[i])
			i++
			j++
		}
	}
	result = append(result, vs[i:]...)
	result = append(result, other[j:]...)
	return result
}

// Intersection produces a ValueSet with only the elements in both
// sets.
func (vs ValueSet) Intersection(other ValueSet) ValueSet {
	if len(vs) == 0 || len(other) == 0 {
		return nil
	}
	var result ValueSet
	for i, j := 0, 0; i < len(vs) && j < len(other); {
		switch {
		case vs[i].Less(other[j]):
			i++
		case other[j].Less(vs[i]):
			j++
		default:
			result = append(result, vs[i])
			i++
			j++
		}
	}
	return result
}

// Minus produces a ValueSet with only the members of vs that don't
// appear in other.
func (vs ValueSet) Minus(other ValueSet) ValueSet {
	if len(vs) == 0 || len(other) == 0 {
		return vs
	}
	var (
		result ValueSet
		i, j   int
	)
	for i < len(vs) && j < len(other) {
		switch {
		case vs[i].Less(other[j]):
			result = append(result, vs[i])
			i++
		case other[j].Less(vs[i]):
			j++
		default:
			i++
			j++
		}
	}
	result = append(result, vs[i:]...)
	return result
}

// Remove produces a ValueSet without the specified element.
func (vs ValueSet) Remove(v Value) ValueSet {
	index := vs.find(v)
	if index >= len(vs) || !ValueEqual(v, vs[index]) {
		return vs
	}
	var result ValueSet
	result = append(result, vs[:index]...)
	result = append(result, vs[index+1:]...)
	return result
}

// Contains tests whether vs contains v.
func (vs ValueSet) Contains(v Value) bool {
	index := vs.find(v)
	return index < len(vs) && ValueEqual(vs[index], v)
}

// BallotSet is a set of Ballot, implemented as a sorted slice.
type BallotSet []Ballot

func (bs BallotSet) find(b Ballot) int {
	return sort.Search(len(bs), func(index int) bool {
		return !bs[index].Less(b)
	})
}

func BallotEqual(a, b Ballot) bool {
	return !a.Less(b) && !b.Less(a)
}

// Add produces a BallotSet containing the members of bs plus the
// element b.
func (bs BallotSet) Add(b Ballot) BallotSet {
	index := bs.find(b)
	if index < len(bs) && BallotEqual(b, bs[index]) {
		return bs
	}
	var result BallotSet
	result = append(result, bs[:index]...)
	result = append(result, b)
	result = append(result, bs[index:]...)
	return result
}

// Union produces a BallotSet containing all the members of both sets.
func (bs BallotSet) Union(other BallotSet) BallotSet {
	if len(bs) == 0 {
		return other
	}
	if len(other) == 0 {
		return bs
	}
	var (
		i, j   int
		result BallotSet
	)
	for i < len(bs) && j < len(other) {
		switch {
		case bs[i].Less(other[j]):
			result = append(result, bs[i])
			i++
		case other[j].Less(bs[i]):
			result = append(result, other[j])
			j++
		default:
			result = append(result, bs[i])
			i++
			j++
		}
	}
	result = append(result, bs[i:]...)
	result = append(result, other[j:]...)
	return result
}

// Intersection produces a BallotSet with only the elements in both
// sets.
func (bs BallotSet) Intersection(other BallotSet) BallotSet {
	if len(bs) == 0 || len(other) == 0 {
		return nil
	}
	var result BallotSet
	for i, j := 0, 0; i < len(bs) && j < len(other); {
		switch {
		case bs[i].Less(other[j]):
			i++
		case other[j].Less(bs[i]):
			j++
		default:
			result = append(result, bs[i])
			i++
			j++
		}
	}
	return result
}

// Minus produces a BallotSet with only the members of bs that don't
// appear in other.
func (bs BallotSet) Minus(other BallotSet) BallotSet {
	if len(bs) == 0 || len(other) == 0 {
		return bs
	}
	var (
		result BallotSet
		i, j   int
	)
	for i < len(bs) && j < len(other) {
		switch {
		case bs[i].Less(other[j]):
			result = append(result, bs[i])
			i++
		case other[j].Less(bs[i]):
			j++
		default:
			i++
			j++
		}
	}
	result = append(result, bs[i:]...)
	return result
}

// Remove produces a BallotSet without the specified element.
func (bs BallotSet) Remove(b Ballot) BallotSet {
	index := bs.find(b)
	if index >= len(bs) || !BallotEqual(b, bs[index]) {
		return bs
	}
	var result BallotSet
	result = append(result, bs[:index]...)
	result = append(result, bs[index+1:]...)
	return result
}

// Contains tests whether bs contains b.
func (bs BallotSet) Contains(b Ballot) bool {
	index := bs.find(b)
	return index < len(bs) && BallotEqual(bs[index], b)
}

// NodeIDSet is a set of NodeID, implemented as a sorted slice.
type NodeIDSet []NodeID

func (ns NodeIDSet) find(n NodeID) int {
	return sort.Search(len(ns), func(index int) bool {
		return !ns[index].Less(n)
	})
}

func NodeIDEqual(a, b NodeID) bool {
	return !a.Less(b) && !b.Less(a)
}

// Add produces a NodeIDSet containing the members of ns plus the
// element n.
func (ns NodeIDSet) Add(n NodeID) NodeIDSet {
	index := ns.find(n)
	if index < len(ns) && NodeIDEqual(n, ns[index]) {
		return ns
	}
	var result NodeIDSet
	result = append(result, ns[:index]...)
	result = append(result, n)
	result = append(result, ns[index:]...)
	return result
}

// Union produces a NodeIDSet containing all the members of both sets.
func (ns NodeIDSet) Union(other NodeIDSet) NodeIDSet {
	if len(ns) == 0 {
		return other
	}
	if len(other) == 0 {
		return ns
	}
	var (
		i, j   int
		result NodeIDSet
	)
	for i < len(ns) && j < len(other) {
		switch {
		case ns[i].Less(other[j]):
			result = append(result, ns[i])
			i++
		case other[j].Less(ns[i]):
			result = append(result, other[j])
			j++
		default:
			result = append(result, ns[i])
			i++
			j++
		}
	}
	result = append(result, ns[i:]...)
	result = append(result, other[j:]...)
	return result
}

// Intersection produces a NodeIDSet with only the elements in both
// sets.
func (ns NodeIDSet) Intersection(other NodeIDSet) NodeIDSet {
	if len(ns) == 0 || len(other) == 0 {
		return nil
	}
	var result NodeIDSet
	for i, j := 0, 0; i < len(ns) && j < len(other); {
		switch {
		case ns[i].Less(other[j]):
			i++
		case other[j].Less(ns[i]):
			j++
		default:
			result = append(result, ns[i])
			i++
			j++
		}
	}
	return result
}

// Minus produces a NodeIDSet with only the members of ns that don't
// appear in other.
func (ns NodeIDSet) Minus(other NodeIDSet) NodeIDSet {
	if len(ns) == 0 || len(other) == 0 {
		return ns
	}
	var (
		result NodeIDSet
		i, j   int
	)
	for i < len(ns) && j < len(other) {
		switch {
		case ns[i].Less(other[j]):
			result = append(result, ns[i])
			i++
		case other[j].Less(ns[i]):
			j++
		default:
			i++
			j++
		}
	}
	result = append(result, ns[i:]...)
	return result
}

// Remove produces a NodeIDSet without the specified element.
func (ns NodeIDSet) Remove(n NodeID) NodeIDSet {
	index := ns.find(n)
	if index >= len(ns) || !NodeIDEqual(n, ns[index]) {
		return ns
	}
	var result NodeIDSet
	result = append(result, ns[:index]...)
	result = append(result, ns[index+1:]...)
	return result
}

// Contains tests whether ns contains n.
func (ns NodeIDSet) Contains(n NodeID) bool {
	index := ns.find(n)
	return index < len(ns) && NodeIDEqual(ns[index], n)
}
