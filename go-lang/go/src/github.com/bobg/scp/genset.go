// +build ignore

package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strings"
	"unicode"
)

func main() {
	out, err := os.Create("set.go")
	if err != nil {
		panic(err)
	}
	defer out.Close()

	fmt.Fprintln(out, "// This file generated by genset.go")
	fmt.Fprintln(out, "package scp\n")
	fmt.Fprintln(out, `import "sort"`)

	types := []string{"Value", "Ballot", "NodeID"}
	for _, typ := range types {
		in, err := os.Open("genset.go")
		if err != nil {
			panic(err)
		}
		func() {
			defer in.Close()

			scanner := bufio.NewScanner(in)
			for scanner.Scan() {
				if scanner.Text() == "// SEPARATOR" {
					break
				}
			}
			for scanner.Scan() {
				letter := unicode.ToLower(rune(typ[0]))
				line := scanner.Text()
				line = strings.Replace(line, "TTT", typ, -1)
				line = strings.Replace(line, "ttts", fmt.Sprintf("%cs", letter), -1)
				line = strings.Replace(line, "ttt", string(letter), -1)
				fmt.Fprintln(out, line)
			}
		}()
	}
}

type TTT int // not really

func (t TTT) Less(other TTT) bool { return false }

// SEPARATOR

// TTTSet is a set of TTT, implemented as a sorted slice.
type TTTSet []TTT

func (ttts TTTSet) find(ttt TTT) int {
	return sort.Search(len(ttts), func(index int) bool {
		return !ttts[index].Less(ttt)
	})
}

func TTTEqual(a, b TTT) bool {
	return !a.Less(b) && !b.Less(a)
}

// Add produces a TTTSet containing the members of ttts plus the
// element ttt.
func (ttts TTTSet) Add(ttt TTT) TTTSet {
	index := ttts.find(ttt)
	if index < len(ttts) && TTTEqual(ttt, ttts[index]) {
		return ttts
	}
	var result TTTSet
	result = append(result, ttts[:index]...)
	result = append(result, ttt)
	result = append(result, ttts[index:]...)
	return result
}

// Union produces a TTTSet containing all the members of both sets.
func (ttts TTTSet) Union(other TTTSet) TTTSet {
	if len(ttts) == 0 {
		return other
	}
	if len(other) == 0 {
		return ttts
	}
	var (
		i, j   int
		result TTTSet
	)
	for i < len(ttts) && j < len(other) {
		switch {
		case ttts[i].Less(other[j]):
			result = append(result, ttts[i])
			i++
		case other[j].Less(ttts[i]):
			result = append(result, other[j])
			j++
		default:
			result = append(result, ttts[i])
			i++
			j++
		}
	}
	result = append(result, ttts[i:]...)
	result = append(result, other[j:]...)
	return result
}

// Intersection produces a TTTSet with only the elements in both
// sets.
func (ttts TTTSet) Intersection(other TTTSet) TTTSet {
	if len(ttts) == 0 || len(other) == 0 {
		return nil
	}
	var result TTTSet
	for i, j := 0, 0; i < len(ttts) && j < len(other); {
		switch {
		case ttts[i].Less(other[j]):
			i++
		case other[j].Less(ttts[i]):
			j++
		default:
			result = append(result, ttts[i])
			i++
			j++
		}
	}
	return result
}

// Minus produces a TTTSet with only the members of ttts that don't
// appear in other.
func (ttts TTTSet) Minus(other TTTSet) TTTSet {
	if len(ttts) == 0 || len(other) == 0 {
		return ttts
	}
	var (
		result TTTSet
		i, j   int
	)
	for i < len(ttts) && j < len(other) {
		switch {
		case ttts[i].Less(other[j]):
			result = append(result, ttts[i])
			i++
		case other[j].Less(ttts[i]):
			j++
		default:
			i++
			j++
		}
	}
	result = append(result, ttts[i:]...)
	return result
}

// Remove produces a TTTSet without the specified element.
func (ttts TTTSet) Remove(ttt TTT) TTTSet {
	index := ttts.find(ttt)
	if index >= len(ttts) || !TTTEqual(ttt, ttts[index]) {
		return ttts
	}
	var result TTTSet
	result = append(result, ttts[:index]...)
	result = append(result, ttts[index+1:]...)
	return result
}

// Contains tests whether ttts contains ttt.
func (ttts TTTSet) Contains(ttt TTT) bool {
	index := ttts.find(ttt)
	return index < len(ttts) && TTTEqual(ttts[index], ttt)
}
